<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>flowers for gloria</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }

        .centered-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            width: 90%;
            max-width: 600px;
            padding: 0 20px;
            box-sizing: border-box;
        }


        .centered-text h1 {
            font-size: 48px;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            text-shadow: 0 4px 20px rgba(255, 183, 213, 0.5),
                         0 0 40px rgba(255, 183, 213, 0.3);
        }

        @media (max-width: 768px) {
            .centered-text h1 {
                font-size: 36px;
                letter-spacing: 1px;
            }
        }

        @media (max-width: 480px) {
            .centered-text h1 {
                font-size: 28px;
                letter-spacing: 0.5px;
            }
        }

        @media (max-width: 360px) {
            .centered-text h1 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="centered-text">
        <h1>Hej Gloria</h1>
        <h1>smacznej kawusi</h1>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const light1 = new THREE.PointLight(0xffffff, 1, 100);
        light1.position.set(10, 10, 10);
        scene.add(light1);

        const light2 = new THREE.PointLight(0xffaaff, 0.5, 100);
        light2.position.set(-10, 5, -5);
        scene.add(light2);

        // Simple petal using circles
        function createPetal(color) {
            const geometry = new THREE.CircleGeometry(0.8, 32);

            geometry.scale(1, 1.3, 1);

            const material = new THREE.MeshStandardMaterial({
                color: color,
                side: THREE.DoubleSide,
                roughness: 0.4,
                metalness: 0.1
            });

            const petal = new THREE.Mesh(geometry, material);

            // Add slight curve
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const dist = Math.sqrt(x * x + y * y);
                positions.setZ(i, -dist * 0.15);
            }
            positions.needsUpdate = true;
            geometry.computeVertexNormals();

            return petal;
        }

        // flower center
        function createFlowerCenter(color) {
            const group = new THREE.Group();

            const diskGeometry = new THREE.CircleGeometry(0.25, 32);
            const diskMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.8
            });
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            group.add(disk);

            // Small dots for detail
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const dotGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const dotMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffff99
                });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.position.set(
                    Math.cos(angle) * 0.15,
                    Math.sin(angle) * 0.15,
                    0.05
                );
                group.add(dot);
            }

            return group;
        }

        // create a complete flower using petals and centers
        function createFlower(petalColor, centerColor, petalCount = 5) {
            const flower = new THREE.Group();

            for (let i = 0; i < petalCount; i++) {
                const petal = createPetal(petalColor);
                const angle = (i / petalCount) * Math.PI * 2;

                petal.position.set(
                    Math.cos(angle) * 0.6,
                    Math.sin(angle) * 0.6,
                    0
                );

                petal.rotation.z = angle + Math.PI / 2;

                flower.add(petal);
            }

            const center = createFlowerCenter(centerColor);
            center.position.z = 0.05;
            flower.add(center);

            return flower;
        }


        function createBranch(length, thickness) {
            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, length / 2, 0.5),
                new THREE.Vector3(0, length, 0)
            );

            const tubeGeometry = new THREE.TubeGeometry(curve, 20, thickness, 8, false);
            const material = new THREE.MeshStandardMaterial({
                color: 0x4a3520,
                roughness: 0.9
            });

            return new THREE.Mesh(tubeGeometry, material);
        }

        // Create multiple flowers at different positions
        const flowers = [];

        // cherry blossoms
        for (let i = 0; i < 3; i++) {
            const flower = createFlower(0xffb7d5, 0xffdd88, 5);
            const angle = (i / 3) * Math.PI * 2;
            const radius = 3 + Math.random() * 2;

            flower.position.set(
                Math.cos(angle) * radius,
                Math.sin(angle) * radius,
                (Math.random() - 0.5) * 2
            );

            flower.rotation.z = Math.random() * Math.PI * 2;
            const scale = 0.8 + Math.random() * 0.4;
            flower.scale.set(scale, scale, scale);

            scene.add(flower);
            flowers.push({
                mesh: flower,
                rotSpeed: 0.001 + Math.random() * 0.002,
                floatSpeed: 0.0005 + Math.random() * 0.001,
                offset: Math.random() * Math.PI * 2
            });
        }

        // white flowers
        for (let i = 0; i < 3; i++) {
            const flower = createFlower(0xffffff, 0xffaa44, 5);
            const angle = (i / 3) * Math.PI * 2 + Math.PI / 3;
            const radius = 3 + Math.random() * 2;

            flower.position.set(
                Math.cos(angle) * radius,
                Math.sin(angle) * radius,
                (Math.random() - 0.5) * 2
            );

            flower.rotation.z = Math.random() * Math.PI * 2;
            const scale = 0.8 + Math.random() * 0.4;
            flower.scale.set(scale, scale, scale);

            scene.add(flower);
            flowers.push({
                mesh: flower,
                rotSpeed: 0.001 + Math.random() * 0.002,
                floatSpeed: 0.0005 + Math.random() * 0.001,
                offset: Math.random() * Math.PI * 2
            });
        }

        //  purple flowers
        for (let i = 0; i < 2; i++) {
            const flower = createFlower(0xe8d5ff, 0xffee66, 6);
            const angle = (i / 2) * Math.PI * 2 + Math.PI / 6;
            const radius = 4 + Math.random() * 1.5;

            flower.position.set(
                Math.cos(angle) * radius,
                Math.sin(angle) * radius,
                (Math.random() - 0.5) * 2
            );

            flower.rotation.z = Math.random() * Math.PI * 2;
            const scale = 0.7 + Math.random() * 0.3;
            flower.scale.set(scale, scale, scale);

            scene.add(flower);
            flowers.push({
                mesh: flower,
                rotSpeed: 0.001 + Math.random() * 0.002,
                floatSpeed: 0.0005 + Math.random() * 0.001,
                offset: Math.random() * Math.PI * 2
            });
        }

        //  floating petals
        const fallingPetals = [];
        for (let i = 0; i < 15; i++) {
            const petal = createPetal(Math.random() > 0.5 ? 0xffb7d5 : 0xffffff);
            petal.position.set(
                (Math.random() - 0.5) * 15,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 8
            );
            petal.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            const scale = 0.3 + Math.random() * 0.3;
            petal.scale.set(scale, scale, scale);

            scene.add(petal);
            fallingPetals.push({
                mesh: petal,
                fallSpeed: 0.01 + Math.random() * 0.02,
                rotSpeed: (Math.random() - 0.5) * 0.05,
                swaySpeed: 0.02 + Math.random() * 0.02,
                swayAmount: 0.5 + Math.random() * 0.5
            });
        }

        // animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // rotation and floating
            flowers.forEach((flower) => {
                flower.mesh.rotation.z += flower.rotSpeed;
                const originalY = flower.mesh.position.y;
                flower.mesh.position.y = originalY + Math.sin(time + flower.offset) * 0.01;
            });

            //  falling petals
            fallingPetals.forEach((petal) => {
                petal.mesh.position.y -= petal.fallSpeed;
                petal.mesh.position.x += Math.sin(time * petal.swaySpeed) * 0.02;
                petal.mesh.rotation.x += petal.rotSpeed;
                petal.mesh.rotation.y += petal.rotSpeed * 0.7;

                if (petal.mesh.position.y < -8) {
                    petal.mesh.position.y = 8;
                    petal.mesh.position.x = (Math.random() - 0.5) * 15;
                }
            });

            // camera movement
            camera.position.x = Math.sin(time * 0.1) * 2;
            camera.position.y = Math.cos(time * 0.15) * 1;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>